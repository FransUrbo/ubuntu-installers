#!/bin/sh

# This script sets method "zfs" for all partitions that have the zfs
# flag set.  It also discovers the logical volumes and creates in them
# a loop partition table and partition.

. /lib/partman/lib/base.sh
. /lib/partman/lib/zfs-base.sh

# Stolen from partman-partitioning/free_space/new/do_option
create_new_partition () {
	open_dialog NEW_PARTITION $1 ext2 $2 $3 $4
	local num id fs mp mplist mpcurrent numparts device
	id=''
	read_line num id x1 x2 x3 x4 x5
	close_dialog

	partitions=''
	numparts=1
	open_dialog PARTITIONS
	while { read_line x1 part x3 x4 x5 x6 x7; [ "$part" ]; }; do
		partitions="$partitions $part"
		numparts=$(($numparts + 1))
	done
	close_dialog

	db_progress START 0 $numparts partman/text/please_wait
	db_progress INFO partman-partitioning/new_state

	if [ "$5" ]; then
		default_fs="$5"
	else
		db_get partman/default_filesystem
		default_fs="$RET"
	fi
	if [ "$id" ] && [ -f "../../$default_fs" ]; then
		# make better defaults for the new partition
		mkdir -p $id
		echo format >$id/method
		>$id/format
		>$id/use_filesystem
		echo "$default_fs" >$id/filesystem
		mkdir -p $id/options
		if [ -f "/lib/partman/mountoptions/${default_fs}_defaults" ]; then
			for op in $(cat "/lib/partman/mountoptions/${default_fs}_defaults"); do
				echo "$op" >"$id/options/$op"
			done
		fi
		mplist='/ /home /usr /var /tmp /usr/local /opt /srv /boot'
		mpcurrent=$(
			for dev in $DEVICES/*; do
				[ -d $dev ] || continue
				cd $dev
				open_dialog PARTITIONS
				while { read_line num id x1 x2 fs x3 x4; [ "$id" ]; }; do
					[ $fs != free ] || continue
					[ -f "$id/method" ] || continue
					[ -f "$id/acting_filesystem" ] || continue
					[ -f "$id/use_filesystem" ] || continue
					[ -f "$id/mountpoint" ] || continue
					echo $(cat $id/mountpoint) # echo ensures 1 line
				done
				close_dialog
			done
		)
		for mp in $mpcurrent; do
			mplist=$(echo $mplist | sed "s,$mp,,")
		done
		mp=''
		for mp in $mplist; do
			break
		done
		if [ "$mp" ]; then
			echo $mp >$id/mountpoint
		fi
		menudir_default_choice /lib/partman/active_partition "$default_fs" mountpoint || true
		menudir_default_choice /lib/partman/choose_partition partition_tree $dev//$id || true
		# setting the bootable flag is too much unnecessary work:
		#   1. check if the disk label supports bootable flag
		#   2. check if the mount point is / or /boot and the partition
		#	  type is `primary'
		#   3. get the current flags
		#   4. add `boot' and set the new flags
		#   5. moreover, when the boot loader is installed in MBR
		#	  no bootable flag is necessary
	fi

	db_progress STEP 1

	for part in $partitions; do
		update_partition $dev $part
		db_progress STEP 1
	done

	db_progress STOP

	if [ "$id" ]; then
		while true; do
			set +e
			local code=0
			ask_active_partition "$dev" "$id" "$num" || code=$?
			if [ "$code" -ge 128 ] && [ "$code" -lt 192 ]; then
				exit "$code" # killed by signal
			elif [ "$code" -ge 100 ]; then
				break
			fi
			set -e
		done
	fi
}

if [ -x /sbin/zpool ]; then
	vgroups=$(/sbin/zpool list -H 2>/dev/null | \
		sed -e 's/\t.*//' | sort)
else
	vgroups=''
fi

for dev in /var/lib/partman/devices/*; do
	[ -d "$dev" ] || continue
	cd $dev
	partitions=
	open_dialog PARTITIONS
	while { read_line num id size type fs path name; [ "$id" ]; }; do
		if [ "$fs" != free ]; then
			partitions="$partitions $id,$path"
		fi
	done
	close_dialog

	# Check if device/partitions are used for ZFS (PV)
	for part in $partitions; do
		set -- $(IFS=, && echo $part)
		id=$1
		path=$2
		zfs=

		# If the device is in fact being used for zfs, mark it as such.
		# This is a hack and it only works for full block devices, not
		# partitions. It makes raid devices used for zfs show up as such.
		if zpool status 2>/dev/null | grep -q "\s$(basename $(cat $dev/device))\s" ; then
			zfs=1
		else
			open_dialog GET_FILE_SYSTEM $id
			read_line fs
			close_dialog
			if [ "$fs" = zfs ]; then
				zfs=1
			fi
		fi
		if [ "$zfs" ]; then
			mkdir -p $id
			echo zfs >$id/method

			if ! [ -e $id/locked ]; then
				vg=$(pv_get_vg $path)
				for vgs in $vgroups; do
					if [ "$vg" = "$vgs" ]; then
						vg_lock_pvs $vg $path
					fi
				done
			fi
		fi
	done

	# Check if device is a logical volume
	if [ -f device ]; then
		# Obtain the VG from the device name
		device=$(cat device)
		case "$device" in
		    /dev/zvol/*)
			vglv=${device#/dev/zvol/}
			vg=$(echo "$vglv" | cut -d"/" -f1)
			;;
		esac
		is_lv=
		for vgs in $vgroups; do
			[ ! "$vgs" = "$vg" ] || is_lv=1
		done

		# If this is a new logical volume
		if [ "$is_lv" ] && [ -z "$partitions" ]; then
			# create a label
			open_dialog NEW_LABEL loop
			close_dialog
			# find the free space
			open_dialog PARTITIONS
			free_space=''
			while { read_line num id size type fs path name; [ "$id" ]; }; do
				if [ "$fs" = free ]; then
					free_space=$id
					free_size=$size
				fi
			done
			close_dialog
			# create partition in the free space
			if [ "$free_space" ]; then
				create_new_partition primary $free_space full $free_size "zfs"
			fi
			open_dialog DISK_UNCHANGED
			close_dialog
		fi
	fi
done
